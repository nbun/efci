interface PermSortPeano where {
import Prelude;
data List a = Nil | Cons a (List a);
data MyBool = MyTrue | MyFalse;
data Nat = O | S Nat;
add 2 :: Nat -> Nat -> Nat;
app 2 :: List a -> List a -> List a;
dec 1 :: Nat -> Nat;
descList 2 :: Nat -> Nat -> List Nat;
double 1 :: Nat -> Nat;
four 0 :: Nat;
guard 2 :: MyBool -> a -> a;
ifThenElse 3 :: MyBool -> a -> a -> a;
insert 2 :: a -> List a -> List a;
isNat 1 :: Nat -> MyBool;
len 1 :: List a -> Nat;
leq 2 :: Nat -> Nat -> MyBool;
main 0 :: List Nat;
mult 2 :: Nat -> Nat -> Nat;
nat13 0 :: Nat;
nat14 0 :: Nat;
nat15 0 :: Nat;
perm 1 :: List a -> List a;
psort 1 :: List Nat -> List Nat;
psort_13 0 :: List Nat;
psort_13_conc 0 :: List Nat;
psort_13_length 0 :: Nat;
psort_14 0 :: List Nat;
sortDescList 1 :: Nat -> List Nat;
sorted 1 :: List Nat -> List Nat;
three 0 :: Nat;
two 0 :: Nat;
instance Prelude.Data a => Prelude.Data (List a) {
  (===) 2;
  aValue 0
};
instance Prelude.Data MyBool {
  (===) 2;
  aValue 0
};
instance Prelude.Data Nat {
  (===) 2;
  aValue 0
};
hiding class Prelude.Data a;
instance Prelude.Data () {
  aValue 0;
  (===) 2
} {-# MODULE Prelude #-};
instance (Prelude.Data a, Prelude.Data b) => Prelude.Data (a, b) {
  aValue 0;
  (===) 2
} {-# MODULE Prelude #-};
instance (Prelude.Data a, Prelude.Data b,
          Prelude.Data c) => Prelude.Data (a, b, c) {
  aValue 0;
  (===) 2
} {-# MODULE Prelude #-};
instance (Prelude.Data a, Prelude.Data b, Prelude.Data c,
          Prelude.Data d) => Prelude.Data (a, b, c, d) {
  aValue 0;
  (===) 2
} {-# MODULE Prelude #-};
instance (Prelude.Data a, Prelude.Data b, Prelude.Data c,
          Prelude.Data d, Prelude.Data e) => Prelude.Data (a, b, c, d, e) {
  aValue 0;
  (===) 2
} {-# MODULE Prelude #-};
instance (Prelude.Data a, Prelude.Data b, Prelude.Data c,
          Prelude.Data d, Prelude.Data e, Prelude.Data f) => Prelude.Data (a,
                                                                           b, c, d, e, f) {
  aValue 0;
  (===) 2
} {-# MODULE Prelude #-};
instance (Prelude.Data a, Prelude.Data b, Prelude.Data c,
          Prelude.Data d, Prelude.Data e, Prelude.Data f,
          Prelude.Data g) => Prelude.Data (a, b, c, d, e, f, g) {
  aValue 0;
  (===) 2
} {-# MODULE Prelude #-};
instance Prelude.Data a => Prelude.Data [a] {
  aValue 0;
  (===) 2
} {-# MODULE Prelude #-};
instance Prelude.Data Prelude.Bool {
  (===) 2;
  aValue 0
} {-# MODULE Prelude #-};
instance Prelude.Data Prelude.Char {
  aValue 0;
  (===) 0
} {-# MODULE Prelude #-};
instance (Prelude.Data a,
          Prelude.Data b) => Prelude.Data (Prelude.Either a b) {
  (===) 2;
  aValue 0
} {-# MODULE Prelude #-};
instance Prelude.Data Prelude.Float {
  aValue 0;
  (===) 0
} {-# MODULE Prelude #-};
instance Prelude.Data Prelude.IOError {
  (===) 2;
  aValue 0
} {-# MODULE Prelude #-};
instance Prelude.Data Prelude.Int {
  aValue 0;
  (===) 0
} {-# MODULE Prelude #-};
instance Prelude.Data a => Prelude.Data (Prelude.Maybe a) {
  (===) 2;
  aValue 0
} {-# MODULE Prelude #-};
instance Prelude.Data Prelude.Ordering {
  (===) 2;
  aValue 0
} {-# MODULE Prelude #-};
hiding data Prelude.Bool;
hiding data Prelude.Char;
hiding data Prelude.Either a b;
hiding data Prelude.Float;
hiding data Prelude.IOError;
hiding data Prelude.Int;
hiding data Prelude.Maybe a;
hiding data Prelude.Ordering
}